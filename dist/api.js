"use strict";
// tslint:disable
/**
 * Small_EOD
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Contact: adam.dobrawy@siecobywatelska.pl
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const globalImportUrl = require("url");
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const base_1 = require("./base");
/**
    * @export
    * @enum {string}
    */
var LetterDirectionEnum;
(function (LetterDirectionEnum) {
    LetterDirectionEnum["IN"] = "IN";
    LetterDirectionEnum["OUT"] = "OUT";
})(LetterDirectionEnum = exports.LetterDirectionEnum || (exports.LetterDirectionEnum = {}));
/**
 * CasesApi - axios parameter creator
 * @export
 */
exports.CasesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {CaseCount} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesCreate: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling casesCreate.');
            }
            const localVarPath = `/cases/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this case.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesDelete: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling casesDelete.');
            }
            const localVarPath = `/cases/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesList: (limit, offset, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/cases/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} casePk
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesNotifiedUserList: (casePk, limit, offset, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'casePk' is not null or undefined
            if (casePk === null || casePk === undefined) {
                throw new base_1.RequiredError('casePk', 'Required parameter casePk was null or undefined when calling casesNotifiedUserList.');
            }
            const localVarPath = `/cases/{case_pk}/notifiedUser/`
                .replace(`{${"case_pk"}}`, encodeURIComponent(String(casePk)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} casePk
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesNotifiedUserRead: (casePk, id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'casePk' is not null or undefined
            if (casePk === null || casePk === undefined) {
                throw new base_1.RequiredError('casePk', 'Required parameter casePk was null or undefined when calling casesNotifiedUserRead.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling casesNotifiedUserRead.');
            }
            const localVarPath = `/cases/{case_pk}/notifiedUser/{id}/`
                .replace(`{${"case_pk"}}`, encodeURIComponent(String(casePk)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this case.
         * @param {CaseCount} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesPartialUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling casesPartialUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling casesPartialUpdate.');
            }
            const localVarPath = `/cases/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this case.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesRead: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling casesRead.');
            }
            const localVarPath = `/cases/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} casePk
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesResponsibleUserList: (casePk, limit, offset, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'casePk' is not null or undefined
            if (casePk === null || casePk === undefined) {
                throw new base_1.RequiredError('casePk', 'Required parameter casePk was null or undefined when calling casesResponsibleUserList.');
            }
            const localVarPath = `/cases/{case_pk}/responsibleUser/`
                .replace(`{${"case_pk"}}`, encodeURIComponent(String(casePk)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} casePk
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesResponsibleUserRead: (casePk, id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'casePk' is not null or undefined
            if (casePk === null || casePk === undefined) {
                throw new base_1.RequiredError('casePk', 'Required parameter casePk was null or undefined when calling casesResponsibleUserRead.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling casesResponsibleUserRead.');
            }
            const localVarPath = `/cases/{case_pk}/responsibleUser/{id}/`
                .replace(`{${"case_pk"}}`, encodeURIComponent(String(casePk)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this case.
         * @param {CaseCount} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling casesUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling casesUpdate.');
            }
            const localVarPath = `/cases/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * CasesApi - functional programming interface
 * @export
 */
exports.CasesApiFp = function (configuration) {
    return {
        /**
         *
         * @param {CaseCount} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesCreate(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CasesApiAxiosParamCreator(configuration).casesCreate(data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this case.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesDelete(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CasesApiAxiosParamCreator(configuration).casesDelete(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesList(limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CasesApiAxiosParamCreator(configuration).casesList(limit, offset, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {string} casePk
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesNotifiedUserList(casePk, limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CasesApiAxiosParamCreator(configuration).casesNotifiedUserList(casePk, limit, offset, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {string} casePk
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesNotifiedUserRead(casePk, id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CasesApiAxiosParamCreator(configuration).casesNotifiedUserRead(casePk, id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this case.
         * @param {CaseCount} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesPartialUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CasesApiAxiosParamCreator(configuration).casesPartialUpdate(id, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this case.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesRead(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CasesApiAxiosParamCreator(configuration).casesRead(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {string} casePk
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesResponsibleUserList(casePk, limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CasesApiAxiosParamCreator(configuration).casesResponsibleUserList(casePk, limit, offset, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {string} casePk
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesResponsibleUserRead(casePk, id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CasesApiAxiosParamCreator(configuration).casesResponsibleUserRead(casePk, id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this case.
         * @param {CaseCount} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CasesApiAxiosParamCreator(configuration).casesUpdate(id, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * CasesApi - factory interface
 * @export
 */
exports.CasesApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @param {CaseCount} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesCreate(data, options) {
            return exports.CasesApiFp(configuration).casesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this case.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesDelete(id, options) {
            return exports.CasesApiFp(configuration).casesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesList(limit, offset, options) {
            return exports.CasesApiFp(configuration).casesList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} casePk
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesNotifiedUserList(casePk, limit, offset, options) {
            return exports.CasesApiFp(configuration).casesNotifiedUserList(casePk, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} casePk
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesNotifiedUserRead(casePk, id, options) {
            return exports.CasesApiFp(configuration).casesNotifiedUserRead(casePk, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this case.
         * @param {CaseCount} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesPartialUpdate(id, data, options) {
            return exports.CasesApiFp(configuration).casesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this case.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesRead(id, options) {
            return exports.CasesApiFp(configuration).casesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} casePk
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesResponsibleUserList(casePk, limit, offset, options) {
            return exports.CasesApiFp(configuration).casesResponsibleUserList(casePk, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} casePk
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesResponsibleUserRead(casePk, id, options) {
            return exports.CasesApiFp(configuration).casesResponsibleUserRead(casePk, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this case.
         * @param {CaseCount} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        casesUpdate(id, data, options) {
            return exports.CasesApiFp(configuration).casesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CasesApi - object-oriented interface
 * @export
 * @class CasesApi
 * @extends {BaseAPI}
 */
class CasesApi extends base_1.BaseAPI {
    /**
     *
     * @param {CaseCount} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    casesCreate(data, options) {
        return exports.CasesApiFp(this.configuration).casesCreate(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this case.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    casesDelete(id, options) {
        return exports.CasesApiFp(this.configuration).casesDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    casesList(limit, offset, options) {
        return exports.CasesApiFp(this.configuration).casesList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} casePk
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    casesNotifiedUserList(casePk, limit, offset, options) {
        return exports.CasesApiFp(this.configuration).casesNotifiedUserList(casePk, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} casePk
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    casesNotifiedUserRead(casePk, id, options) {
        return exports.CasesApiFp(this.configuration).casesNotifiedUserRead(casePk, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this case.
     * @param {CaseCount} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    casesPartialUpdate(id, data, options) {
        return exports.CasesApiFp(this.configuration).casesPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this case.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    casesRead(id, options) {
        return exports.CasesApiFp(this.configuration).casesRead(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} casePk
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    casesResponsibleUserList(casePk, limit, offset, options) {
        return exports.CasesApiFp(this.configuration).casesResponsibleUserList(casePk, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} casePk
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    casesResponsibleUserRead(casePk, id, options) {
        return exports.CasesApiFp(this.configuration).casesResponsibleUserRead(casePk, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this case.
     * @param {CaseCount} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CasesApi
     */
    casesUpdate(id, data, options) {
        return exports.CasesApiFp(this.configuration).casesUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CasesApi = CasesApi;
/**
 * ChannelsApi - axios parameter creator
 * @export
 */
exports.ChannelsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {Channel} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsCreate: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling channelsCreate.');
            }
            const localVarPath = `/channels/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this channel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsDelete: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling channelsDelete.');
            }
            const localVarPath = `/channels/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsList: (limit, offset, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/channels/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this channel.
         * @param {Channel} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsPartialUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling channelsPartialUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling channelsPartialUpdate.');
            }
            const localVarPath = `/channels/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this channel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsRead: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling channelsRead.');
            }
            const localVarPath = `/channels/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this channel.
         * @param {Channel} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling channelsUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling channelsUpdate.');
            }
            const localVarPath = `/channels/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ChannelsApi - functional programming interface
 * @export
 */
exports.ChannelsApiFp = function (configuration) {
    return {
        /**
         *
         * @param {Channel} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsCreate(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ChannelsApiAxiosParamCreator(configuration).channelsCreate(data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this channel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsDelete(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ChannelsApiAxiosParamCreator(configuration).channelsDelete(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsList(limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ChannelsApiAxiosParamCreator(configuration).channelsList(limit, offset, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this channel.
         * @param {Channel} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsPartialUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ChannelsApiAxiosParamCreator(configuration).channelsPartialUpdate(id, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this channel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsRead(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ChannelsApiAxiosParamCreator(configuration).channelsRead(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this channel.
         * @param {Channel} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ChannelsApiAxiosParamCreator(configuration).channelsUpdate(id, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ChannelsApi - factory interface
 * @export
 */
exports.ChannelsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @param {Channel} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsCreate(data, options) {
            return exports.ChannelsApiFp(configuration).channelsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this channel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsDelete(id, options) {
            return exports.ChannelsApiFp(configuration).channelsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsList(limit, offset, options) {
            return exports.ChannelsApiFp(configuration).channelsList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this channel.
         * @param {Channel} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsPartialUpdate(id, data, options) {
            return exports.ChannelsApiFp(configuration).channelsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this channel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsRead(id, options) {
            return exports.ChannelsApiFp(configuration).channelsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this channel.
         * @param {Channel} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelsUpdate(id, data, options) {
            return exports.ChannelsApiFp(configuration).channelsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ChannelsApi - object-oriented interface
 * @export
 * @class ChannelsApi
 * @extends {BaseAPI}
 */
class ChannelsApi extends base_1.BaseAPI {
    /**
     *
     * @param {Channel} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    channelsCreate(data, options) {
        return exports.ChannelsApiFp(this.configuration).channelsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this channel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    channelsDelete(id, options) {
        return exports.ChannelsApiFp(this.configuration).channelsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    channelsList(limit, offset, options) {
        return exports.ChannelsApiFp(this.configuration).channelsList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this channel.
     * @param {Channel} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    channelsPartialUpdate(id, data, options) {
        return exports.ChannelsApiFp(this.configuration).channelsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this channel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    channelsRead(id, options) {
        return exports.ChannelsApiFp(this.configuration).channelsRead(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this channel.
     * @param {Channel} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    channelsUpdate(id, data, options) {
        return exports.ChannelsApiFp(this.configuration).channelsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ChannelsApi = ChannelsApi;
/**
 * CollectionsApi - axios parameter creator
 * @export
 */
exports.CollectionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {string} casePk
         * @param {string} collectionPk
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCasesEventsList: (casePk, collectionPk, limit, offset, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'casePk' is not null or undefined
            if (casePk === null || casePk === undefined) {
                throw new base_1.RequiredError('casePk', 'Required parameter casePk was null or undefined when calling collectionsCasesEventsList.');
            }
            // verify required parameter 'collectionPk' is not null or undefined
            if (collectionPk === null || collectionPk === undefined) {
                throw new base_1.RequiredError('collectionPk', 'Required parameter collectionPk was null or undefined when calling collectionsCasesEventsList.');
            }
            const localVarPath = `/collections/{collection_pk}/cases/{case_pk}/events/`
                .replace(`{${"case_pk"}}`, encodeURIComponent(String(casePk)))
                .replace(`{${"collection_pk"}}`, encodeURIComponent(String(collectionPk)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} casePk
         * @param {string} collectionPk
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCasesEventsRead: (casePk, collectionPk, id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'casePk' is not null or undefined
            if (casePk === null || casePk === undefined) {
                throw new base_1.RequiredError('casePk', 'Required parameter casePk was null or undefined when calling collectionsCasesEventsRead.');
            }
            // verify required parameter 'collectionPk' is not null or undefined
            if (collectionPk === null || collectionPk === undefined) {
                throw new base_1.RequiredError('collectionPk', 'Required parameter collectionPk was null or undefined when calling collectionsCasesEventsRead.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling collectionsCasesEventsRead.');
            }
            const localVarPath = `/collections/{collection_pk}/cases/{case_pk}/events/{id}/`
                .replace(`{${"case_pk"}}`, encodeURIComponent(String(casePk)))
                .replace(`{${"collection_pk"}}`, encodeURIComponent(String(collectionPk)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} casePk
         * @param {string} collectionPk
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCasesLettersList: (casePk, collectionPk, limit, offset, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'casePk' is not null or undefined
            if (casePk === null || casePk === undefined) {
                throw new base_1.RequiredError('casePk', 'Required parameter casePk was null or undefined when calling collectionsCasesLettersList.');
            }
            // verify required parameter 'collectionPk' is not null or undefined
            if (collectionPk === null || collectionPk === undefined) {
                throw new base_1.RequiredError('collectionPk', 'Required parameter collectionPk was null or undefined when calling collectionsCasesLettersList.');
            }
            const localVarPath = `/collections/{collection_pk}/cases/{case_pk}/letters/`
                .replace(`{${"case_pk"}}`, encodeURIComponent(String(casePk)))
                .replace(`{${"collection_pk"}}`, encodeURIComponent(String(collectionPk)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} casePk
         * @param {string} collectionPk
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCasesLettersRead: (casePk, collectionPk, id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'casePk' is not null or undefined
            if (casePk === null || casePk === undefined) {
                throw new base_1.RequiredError('casePk', 'Required parameter casePk was null or undefined when calling collectionsCasesLettersRead.');
            }
            // verify required parameter 'collectionPk' is not null or undefined
            if (collectionPk === null || collectionPk === undefined) {
                throw new base_1.RequiredError('collectionPk', 'Required parameter collectionPk was null or undefined when calling collectionsCasesLettersRead.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling collectionsCasesLettersRead.');
            }
            const localVarPath = `/collections/{collection_pk}/cases/{case_pk}/letters/{id}/`
                .replace(`{${"case_pk"}}`, encodeURIComponent(String(casePk)))
                .replace(`{${"collection_pk"}}`, encodeURIComponent(String(collectionPk)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} collectionPk
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCasesList: (collectionPk, limit, offset, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'collectionPk' is not null or undefined
            if (collectionPk === null || collectionPk === undefined) {
                throw new base_1.RequiredError('collectionPk', 'Required parameter collectionPk was null or undefined when calling collectionsCasesList.');
            }
            const localVarPath = `/collections/{collection_pk}/cases/`
                .replace(`{${"collection_pk"}}`, encodeURIComponent(String(collectionPk)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} casePk
         * @param {string} collectionPk
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCasesNotesList: (casePk, collectionPk, limit, offset, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'casePk' is not null or undefined
            if (casePk === null || casePk === undefined) {
                throw new base_1.RequiredError('casePk', 'Required parameter casePk was null or undefined when calling collectionsCasesNotesList.');
            }
            // verify required parameter 'collectionPk' is not null or undefined
            if (collectionPk === null || collectionPk === undefined) {
                throw new base_1.RequiredError('collectionPk', 'Required parameter collectionPk was null or undefined when calling collectionsCasesNotesList.');
            }
            const localVarPath = `/collections/{collection_pk}/cases/{case_pk}/notes/`
                .replace(`{${"case_pk"}}`, encodeURIComponent(String(casePk)))
                .replace(`{${"collection_pk"}}`, encodeURIComponent(String(collectionPk)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} casePk
         * @param {string} collectionPk
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCasesNotesRead: (casePk, collectionPk, id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'casePk' is not null or undefined
            if (casePk === null || casePk === undefined) {
                throw new base_1.RequiredError('casePk', 'Required parameter casePk was null or undefined when calling collectionsCasesNotesRead.');
            }
            // verify required parameter 'collectionPk' is not null or undefined
            if (collectionPk === null || collectionPk === undefined) {
                throw new base_1.RequiredError('collectionPk', 'Required parameter collectionPk was null or undefined when calling collectionsCasesNotesRead.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling collectionsCasesNotesRead.');
            }
            const localVarPath = `/collections/{collection_pk}/cases/{case_pk}/notes/{id}/`
                .replace(`{${"case_pk"}}`, encodeURIComponent(String(casePk)))
                .replace(`{${"collection_pk"}}`, encodeURIComponent(String(collectionPk)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} collectionPk
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCasesRead: (collectionPk, id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'collectionPk' is not null or undefined
            if (collectionPk === null || collectionPk === undefined) {
                throw new base_1.RequiredError('collectionPk', 'Required parameter collectionPk was null or undefined when calling collectionsCasesRead.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling collectionsCasesRead.');
            }
            const localVarPath = `/collections/{collection_pk}/cases/{id}/`
                .replace(`{${"collection_pk"}}`, encodeURIComponent(String(collectionPk)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {Collection} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCreate: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling collectionsCreate.');
            }
            const localVarPath = `/collections/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsDelete: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling collectionsDelete.');
            }
            const localVarPath = `/collections/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsList: (limit, offset, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/collections/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this collection.
         * @param {Collection} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsPartialUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling collectionsPartialUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling collectionsPartialUpdate.');
            }
            const localVarPath = `/collections/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsRead: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling collectionsRead.');
            }
            const localVarPath = `/collections/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} collectionPk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsTokensCreate: (collectionPk, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'collectionPk' is not null or undefined
            if (collectionPk === null || collectionPk === undefined) {
                throw new base_1.RequiredError('collectionPk', 'Required parameter collectionPk was null or undefined when calling collectionsTokensCreate.');
            }
            const localVarPath = `/collections/{collection_pk}/tokens/`
                .replace(`{${"collection_pk"}}`, encodeURIComponent(String(collectionPk)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this collection.
         * @param {Collection} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling collectionsUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling collectionsUpdate.');
            }
            const localVarPath = `/collections/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * CollectionsApi - functional programming interface
 * @export
 */
exports.CollectionsApiFp = function (configuration) {
    return {
        /**
         *
         * @param {string} casePk
         * @param {string} collectionPk
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCasesEventsList(casePk, collectionPk, limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CollectionsApiAxiosParamCreator(configuration).collectionsCasesEventsList(casePk, collectionPk, limit, offset, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {string} casePk
         * @param {string} collectionPk
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCasesEventsRead(casePk, collectionPk, id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CollectionsApiAxiosParamCreator(configuration).collectionsCasesEventsRead(casePk, collectionPk, id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {string} casePk
         * @param {string} collectionPk
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCasesLettersList(casePk, collectionPk, limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CollectionsApiAxiosParamCreator(configuration).collectionsCasesLettersList(casePk, collectionPk, limit, offset, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {string} casePk
         * @param {string} collectionPk
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCasesLettersRead(casePk, collectionPk, id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CollectionsApiAxiosParamCreator(configuration).collectionsCasesLettersRead(casePk, collectionPk, id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {string} collectionPk
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCasesList(collectionPk, limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CollectionsApiAxiosParamCreator(configuration).collectionsCasesList(collectionPk, limit, offset, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {string} casePk
         * @param {string} collectionPk
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCasesNotesList(casePk, collectionPk, limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CollectionsApiAxiosParamCreator(configuration).collectionsCasesNotesList(casePk, collectionPk, limit, offset, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {string} casePk
         * @param {string} collectionPk
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCasesNotesRead(casePk, collectionPk, id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CollectionsApiAxiosParamCreator(configuration).collectionsCasesNotesRead(casePk, collectionPk, id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {string} collectionPk
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCasesRead(collectionPk, id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CollectionsApiAxiosParamCreator(configuration).collectionsCasesRead(collectionPk, id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {Collection} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCreate(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CollectionsApiAxiosParamCreator(configuration).collectionsCreate(data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsDelete(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CollectionsApiAxiosParamCreator(configuration).collectionsDelete(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsList(limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CollectionsApiAxiosParamCreator(configuration).collectionsList(limit, offset, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this collection.
         * @param {Collection} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsPartialUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CollectionsApiAxiosParamCreator(configuration).collectionsPartialUpdate(id, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsRead(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CollectionsApiAxiosParamCreator(configuration).collectionsRead(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {string} collectionPk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsTokensCreate(collectionPk, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CollectionsApiAxiosParamCreator(configuration).collectionsTokensCreate(collectionPk, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this collection.
         * @param {Collection} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CollectionsApiAxiosParamCreator(configuration).collectionsUpdate(id, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * CollectionsApi - factory interface
 * @export
 */
exports.CollectionsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @param {string} casePk
         * @param {string} collectionPk
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCasesEventsList(casePk, collectionPk, limit, offset, options) {
            return exports.CollectionsApiFp(configuration).collectionsCasesEventsList(casePk, collectionPk, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} casePk
         * @param {string} collectionPk
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCasesEventsRead(casePk, collectionPk, id, options) {
            return exports.CollectionsApiFp(configuration).collectionsCasesEventsRead(casePk, collectionPk, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} casePk
         * @param {string} collectionPk
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCasesLettersList(casePk, collectionPk, limit, offset, options) {
            return exports.CollectionsApiFp(configuration).collectionsCasesLettersList(casePk, collectionPk, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} casePk
         * @param {string} collectionPk
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCasesLettersRead(casePk, collectionPk, id, options) {
            return exports.CollectionsApiFp(configuration).collectionsCasesLettersRead(casePk, collectionPk, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} collectionPk
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCasesList(collectionPk, limit, offset, options) {
            return exports.CollectionsApiFp(configuration).collectionsCasesList(collectionPk, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} casePk
         * @param {string} collectionPk
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCasesNotesList(casePk, collectionPk, limit, offset, options) {
            return exports.CollectionsApiFp(configuration).collectionsCasesNotesList(casePk, collectionPk, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} casePk
         * @param {string} collectionPk
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCasesNotesRead(casePk, collectionPk, id, options) {
            return exports.CollectionsApiFp(configuration).collectionsCasesNotesRead(casePk, collectionPk, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} collectionPk
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCasesRead(collectionPk, id, options) {
            return exports.CollectionsApiFp(configuration).collectionsCasesRead(collectionPk, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {Collection} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsCreate(data, options) {
            return exports.CollectionsApiFp(configuration).collectionsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsDelete(id, options) {
            return exports.CollectionsApiFp(configuration).collectionsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsList(limit, offset, options) {
            return exports.CollectionsApiFp(configuration).collectionsList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this collection.
         * @param {Collection} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsPartialUpdate(id, data, options) {
            return exports.CollectionsApiFp(configuration).collectionsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsRead(id, options) {
            return exports.CollectionsApiFp(configuration).collectionsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} collectionPk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsTokensCreate(collectionPk, options) {
            return exports.CollectionsApiFp(configuration).collectionsTokensCreate(collectionPk, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this collection.
         * @param {Collection} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectionsUpdate(id, data, options) {
            return exports.CollectionsApiFp(configuration).collectionsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
class CollectionsApi extends base_1.BaseAPI {
    /**
     *
     * @param {string} casePk
     * @param {string} collectionPk
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    collectionsCasesEventsList(casePk, collectionPk, limit, offset, options) {
        return exports.CollectionsApiFp(this.configuration).collectionsCasesEventsList(casePk, collectionPk, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} casePk
     * @param {string} collectionPk
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    collectionsCasesEventsRead(casePk, collectionPk, id, options) {
        return exports.CollectionsApiFp(this.configuration).collectionsCasesEventsRead(casePk, collectionPk, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} casePk
     * @param {string} collectionPk
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    collectionsCasesLettersList(casePk, collectionPk, limit, offset, options) {
        return exports.CollectionsApiFp(this.configuration).collectionsCasesLettersList(casePk, collectionPk, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} casePk
     * @param {string} collectionPk
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    collectionsCasesLettersRead(casePk, collectionPk, id, options) {
        return exports.CollectionsApiFp(this.configuration).collectionsCasesLettersRead(casePk, collectionPk, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} collectionPk
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    collectionsCasesList(collectionPk, limit, offset, options) {
        return exports.CollectionsApiFp(this.configuration).collectionsCasesList(collectionPk, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} casePk
     * @param {string} collectionPk
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    collectionsCasesNotesList(casePk, collectionPk, limit, offset, options) {
        return exports.CollectionsApiFp(this.configuration).collectionsCasesNotesList(casePk, collectionPk, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} casePk
     * @param {string} collectionPk
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    collectionsCasesNotesRead(casePk, collectionPk, id, options) {
        return exports.CollectionsApiFp(this.configuration).collectionsCasesNotesRead(casePk, collectionPk, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} collectionPk
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    collectionsCasesRead(collectionPk, id, options) {
        return exports.CollectionsApiFp(this.configuration).collectionsCasesRead(collectionPk, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {Collection} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    collectionsCreate(data, options) {
        return exports.CollectionsApiFp(this.configuration).collectionsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this collection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    collectionsDelete(id, options) {
        return exports.CollectionsApiFp(this.configuration).collectionsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    collectionsList(limit, offset, options) {
        return exports.CollectionsApiFp(this.configuration).collectionsList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this collection.
     * @param {Collection} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    collectionsPartialUpdate(id, data, options) {
        return exports.CollectionsApiFp(this.configuration).collectionsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this collection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    collectionsRead(id, options) {
        return exports.CollectionsApiFp(this.configuration).collectionsRead(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} collectionPk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    collectionsTokensCreate(collectionPk, options) {
        return exports.CollectionsApiFp(this.configuration).collectionsTokensCreate(collectionPk, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this collection.
     * @param {Collection} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    collectionsUpdate(id, data, options) {
        return exports.CollectionsApiFp(this.configuration).collectionsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CollectionsApi = CollectionsApi;
/**
 * DescriptionsApi - axios parameter creator
 * @export
 */
exports.DescriptionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {Description} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptionsCreate: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling descriptionsCreate.');
            }
            const localVarPath = `/descriptions/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this description.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptionsDelete: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling descriptionsDelete.');
            }
            const localVarPath = `/descriptions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptionsList: (limit, offset, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/descriptions/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this description.
         * @param {Description} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptionsPartialUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling descriptionsPartialUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling descriptionsPartialUpdate.');
            }
            const localVarPath = `/descriptions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this description.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptionsRead: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling descriptionsRead.');
            }
            const localVarPath = `/descriptions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this description.
         * @param {Description} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptionsUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling descriptionsUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling descriptionsUpdate.');
            }
            const localVarPath = `/descriptions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DescriptionsApi - functional programming interface
 * @export
 */
exports.DescriptionsApiFp = function (configuration) {
    return {
        /**
         *
         * @param {Description} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptionsCreate(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DescriptionsApiAxiosParamCreator(configuration).descriptionsCreate(data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this description.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptionsDelete(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DescriptionsApiAxiosParamCreator(configuration).descriptionsDelete(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptionsList(limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DescriptionsApiAxiosParamCreator(configuration).descriptionsList(limit, offset, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this description.
         * @param {Description} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptionsPartialUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DescriptionsApiAxiosParamCreator(configuration).descriptionsPartialUpdate(id, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this description.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptionsRead(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DescriptionsApiAxiosParamCreator(configuration).descriptionsRead(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this description.
         * @param {Description} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptionsUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DescriptionsApiAxiosParamCreator(configuration).descriptionsUpdate(id, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * DescriptionsApi - factory interface
 * @export
 */
exports.DescriptionsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @param {Description} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptionsCreate(data, options) {
            return exports.DescriptionsApiFp(configuration).descriptionsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this description.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptionsDelete(id, options) {
            return exports.DescriptionsApiFp(configuration).descriptionsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptionsList(limit, offset, options) {
            return exports.DescriptionsApiFp(configuration).descriptionsList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this description.
         * @param {Description} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptionsPartialUpdate(id, data, options) {
            return exports.DescriptionsApiFp(configuration).descriptionsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this description.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptionsRead(id, options) {
            return exports.DescriptionsApiFp(configuration).descriptionsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this description.
         * @param {Description} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        descriptionsUpdate(id, data, options) {
            return exports.DescriptionsApiFp(configuration).descriptionsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DescriptionsApi - object-oriented interface
 * @export
 * @class DescriptionsApi
 * @extends {BaseAPI}
 */
class DescriptionsApi extends base_1.BaseAPI {
    /**
     *
     * @param {Description} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DescriptionsApi
     */
    descriptionsCreate(data, options) {
        return exports.DescriptionsApiFp(this.configuration).descriptionsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this description.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DescriptionsApi
     */
    descriptionsDelete(id, options) {
        return exports.DescriptionsApiFp(this.configuration).descriptionsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DescriptionsApi
     */
    descriptionsList(limit, offset, options) {
        return exports.DescriptionsApiFp(this.configuration).descriptionsList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this description.
     * @param {Description} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DescriptionsApi
     */
    descriptionsPartialUpdate(id, data, options) {
        return exports.DescriptionsApiFp(this.configuration).descriptionsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this description.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DescriptionsApi
     */
    descriptionsRead(id, options) {
        return exports.DescriptionsApiFp(this.configuration).descriptionsRead(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this description.
     * @param {Description} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DescriptionsApi
     */
    descriptionsUpdate(id, data, options) {
        return exports.DescriptionsApiFp(this.configuration).descriptionsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DescriptionsApi = DescriptionsApi;
/**
 * DictionariesApi - axios parameter creator
 * @export
 */
exports.DictionariesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {Dictionary} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dictionariesCreate: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling dictionariesCreate.');
            }
            const localVarPath = `/dictionaries/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this dictionary.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dictionariesDelete: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling dictionariesDelete.');
            }
            const localVarPath = `/dictionaries/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dictionariesList: (limit, offset, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/dictionaries/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this dictionary.
         * @param {Dictionary} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dictionariesPartialUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling dictionariesPartialUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling dictionariesPartialUpdate.');
            }
            const localVarPath = `/dictionaries/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this dictionary.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dictionariesRead: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling dictionariesRead.');
            }
            const localVarPath = `/dictionaries/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this dictionary.
         * @param {Dictionary} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dictionariesUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling dictionariesUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling dictionariesUpdate.');
            }
            const localVarPath = `/dictionaries/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DictionariesApi - functional programming interface
 * @export
 */
exports.DictionariesApiFp = function (configuration) {
    return {
        /**
         *
         * @param {Dictionary} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dictionariesCreate(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DictionariesApiAxiosParamCreator(configuration).dictionariesCreate(data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this dictionary.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dictionariesDelete(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DictionariesApiAxiosParamCreator(configuration).dictionariesDelete(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dictionariesList(limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DictionariesApiAxiosParamCreator(configuration).dictionariesList(limit, offset, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this dictionary.
         * @param {Dictionary} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dictionariesPartialUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DictionariesApiAxiosParamCreator(configuration).dictionariesPartialUpdate(id, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this dictionary.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dictionariesRead(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DictionariesApiAxiosParamCreator(configuration).dictionariesRead(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this dictionary.
         * @param {Dictionary} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dictionariesUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DictionariesApiAxiosParamCreator(configuration).dictionariesUpdate(id, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * DictionariesApi - factory interface
 * @export
 */
exports.DictionariesApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @param {Dictionary} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dictionariesCreate(data, options) {
            return exports.DictionariesApiFp(configuration).dictionariesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this dictionary.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dictionariesDelete(id, options) {
            return exports.DictionariesApiFp(configuration).dictionariesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dictionariesList(limit, offset, options) {
            return exports.DictionariesApiFp(configuration).dictionariesList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this dictionary.
         * @param {Dictionary} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dictionariesPartialUpdate(id, data, options) {
            return exports.DictionariesApiFp(configuration).dictionariesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this dictionary.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dictionariesRead(id, options) {
            return exports.DictionariesApiFp(configuration).dictionariesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this dictionary.
         * @param {Dictionary} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dictionariesUpdate(id, data, options) {
            return exports.DictionariesApiFp(configuration).dictionariesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DictionariesApi - object-oriented interface
 * @export
 * @class DictionariesApi
 * @extends {BaseAPI}
 */
class DictionariesApi extends base_1.BaseAPI {
    /**
     *
     * @param {Dictionary} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DictionariesApi
     */
    dictionariesCreate(data, options) {
        return exports.DictionariesApiFp(this.configuration).dictionariesCreate(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this dictionary.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DictionariesApi
     */
    dictionariesDelete(id, options) {
        return exports.DictionariesApiFp(this.configuration).dictionariesDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DictionariesApi
     */
    dictionariesList(limit, offset, options) {
        return exports.DictionariesApiFp(this.configuration).dictionariesList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this dictionary.
     * @param {Dictionary} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DictionariesApi
     */
    dictionariesPartialUpdate(id, data, options) {
        return exports.DictionariesApiFp(this.configuration).dictionariesPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this dictionary.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DictionariesApi
     */
    dictionariesRead(id, options) {
        return exports.DictionariesApiFp(this.configuration).dictionariesRead(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this dictionary.
     * @param {Dictionary} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DictionariesApi
     */
    dictionariesUpdate(id, data, options) {
        return exports.DictionariesApiFp(this.configuration).dictionariesUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DictionariesApi = DictionariesApi;
/**
 * EventsApi - axios parameter creator
 * @export
 */
exports.EventsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {Event} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsCreate: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling eventsCreate.');
            }
            const localVarPath = `/events/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsDelete: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling eventsDelete.');
            }
            const localVarPath = `/events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsList: (limit, offset, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/events/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this event.
         * @param {Event} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsPartialUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling eventsPartialUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling eventsPartialUpdate.');
            }
            const localVarPath = `/events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsRead: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling eventsRead.');
            }
            const localVarPath = `/events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this event.
         * @param {Event} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling eventsUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling eventsUpdate.');
            }
            const localVarPath = `/events/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * EventsApi - functional programming interface
 * @export
 */
exports.EventsApiFp = function (configuration) {
    return {
        /**
         *
         * @param {Event} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsCreate(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.EventsApiAxiosParamCreator(configuration).eventsCreate(data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsDelete(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.EventsApiAxiosParamCreator(configuration).eventsDelete(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsList(limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.EventsApiAxiosParamCreator(configuration).eventsList(limit, offset, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this event.
         * @param {Event} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsPartialUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.EventsApiAxiosParamCreator(configuration).eventsPartialUpdate(id, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsRead(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.EventsApiAxiosParamCreator(configuration).eventsRead(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this event.
         * @param {Event} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.EventsApiAxiosParamCreator(configuration).eventsUpdate(id, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * EventsApi - factory interface
 * @export
 */
exports.EventsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @param {Event} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsCreate(data, options) {
            return exports.EventsApiFp(configuration).eventsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsDelete(id, options) {
            return exports.EventsApiFp(configuration).eventsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsList(limit, offset, options) {
            return exports.EventsApiFp(configuration).eventsList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this event.
         * @param {Event} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsPartialUpdate(id, data, options) {
            return exports.EventsApiFp(configuration).eventsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsRead(id, options) {
            return exports.EventsApiFp(configuration).eventsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this event.
         * @param {Event} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsUpdate(id, data, options) {
            return exports.EventsApiFp(configuration).eventsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
class EventsApi extends base_1.BaseAPI {
    /**
     *
     * @param {Event} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    eventsCreate(data, options) {
        return exports.EventsApiFp(this.configuration).eventsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    eventsDelete(id, options) {
        return exports.EventsApiFp(this.configuration).eventsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    eventsList(limit, offset, options) {
        return exports.EventsApiFp(this.configuration).eventsList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this event.
     * @param {Event} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    eventsPartialUpdate(id, data, options) {
        return exports.EventsApiFp(this.configuration).eventsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    eventsRead(id, options) {
        return exports.EventsApiFp(this.configuration).eventsRead(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this event.
     * @param {Event} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    eventsUpdate(id, data, options) {
        return exports.EventsApiFp(this.configuration).eventsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.EventsApi = EventsApi;
/**
 * InstitutionsApi - axios parameter creator
 * @export
 */
exports.InstitutionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {Institution} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        institutionsCreate: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling institutionsCreate.');
            }
            const localVarPath = `/institutions/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this institution.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        institutionsDelete: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling institutionsDelete.');
            }
            const localVarPath = `/institutions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        institutionsList: (limit, offset, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/institutions/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this institution.
         * @param {Institution} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        institutionsPartialUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling institutionsPartialUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling institutionsPartialUpdate.');
            }
            const localVarPath = `/institutions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this institution.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        institutionsRead: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling institutionsRead.');
            }
            const localVarPath = `/institutions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this institution.
         * @param {Institution} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        institutionsUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling institutionsUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling institutionsUpdate.');
            }
            const localVarPath = `/institutions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * InstitutionsApi - functional programming interface
 * @export
 */
exports.InstitutionsApiFp = function (configuration) {
    return {
        /**
         *
         * @param {Institution} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        institutionsCreate(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InstitutionsApiAxiosParamCreator(configuration).institutionsCreate(data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this institution.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        institutionsDelete(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InstitutionsApiAxiosParamCreator(configuration).institutionsDelete(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        institutionsList(limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InstitutionsApiAxiosParamCreator(configuration).institutionsList(limit, offset, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this institution.
         * @param {Institution} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        institutionsPartialUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InstitutionsApiAxiosParamCreator(configuration).institutionsPartialUpdate(id, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this institution.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        institutionsRead(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InstitutionsApiAxiosParamCreator(configuration).institutionsRead(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this institution.
         * @param {Institution} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        institutionsUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.InstitutionsApiAxiosParamCreator(configuration).institutionsUpdate(id, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * InstitutionsApi - factory interface
 * @export
 */
exports.InstitutionsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @param {Institution} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        institutionsCreate(data, options) {
            return exports.InstitutionsApiFp(configuration).institutionsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this institution.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        institutionsDelete(id, options) {
            return exports.InstitutionsApiFp(configuration).institutionsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        institutionsList(limit, offset, options) {
            return exports.InstitutionsApiFp(configuration).institutionsList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this institution.
         * @param {Institution} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        institutionsPartialUpdate(id, data, options) {
            return exports.InstitutionsApiFp(configuration).institutionsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this institution.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        institutionsRead(id, options) {
            return exports.InstitutionsApiFp(configuration).institutionsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this institution.
         * @param {Institution} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        institutionsUpdate(id, data, options) {
            return exports.InstitutionsApiFp(configuration).institutionsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * InstitutionsApi - object-oriented interface
 * @export
 * @class InstitutionsApi
 * @extends {BaseAPI}
 */
class InstitutionsApi extends base_1.BaseAPI {
    /**
     *
     * @param {Institution} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstitutionsApi
     */
    institutionsCreate(data, options) {
        return exports.InstitutionsApiFp(this.configuration).institutionsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this institution.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstitutionsApi
     */
    institutionsDelete(id, options) {
        return exports.InstitutionsApiFp(this.configuration).institutionsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstitutionsApi
     */
    institutionsList(limit, offset, options) {
        return exports.InstitutionsApiFp(this.configuration).institutionsList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this institution.
     * @param {Institution} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstitutionsApi
     */
    institutionsPartialUpdate(id, data, options) {
        return exports.InstitutionsApiFp(this.configuration).institutionsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this institution.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstitutionsApi
     */
    institutionsRead(id, options) {
        return exports.InstitutionsApiFp(this.configuration).institutionsRead(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this institution.
     * @param {Institution} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstitutionsApi
     */
    institutionsUpdate(id, data, options) {
        return exports.InstitutionsApiFp(this.configuration).institutionsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.InstitutionsApi = InstitutionsApi;
/**
 * LettersApi - axios parameter creator
 * @export
 */
exports.LettersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {Letter} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersCreate: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling lettersCreate.');
            }
            const localVarPath = `/letters/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this letter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersDelete: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling lettersDelete.');
            }
            const localVarPath = `/letters/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Generates pre-signed form data for uploading files to object storage.
         * @param {SignRequest} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersFileSignCreate: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling lettersFileSignCreate.');
            }
            const localVarPath = `/letters/file/sign`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} letterPk
         * @param {ModelFile} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersFilesCreate: (letterPk, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'letterPk' is not null or undefined
            if (letterPk === null || letterPk === undefined) {
                throw new base_1.RequiredError('letterPk', 'Required parameter letterPk was null or undefined when calling lettersFilesCreate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling lettersFilesCreate.');
            }
            const localVarPath = `/letters/{letter_pk}/files/`
                .replace(`{${"letter_pk"}}`, encodeURIComponent(String(letterPk)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {string} letterPk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersFilesDelete: (id, letterPk, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling lettersFilesDelete.');
            }
            // verify required parameter 'letterPk' is not null or undefined
            if (letterPk === null || letterPk === undefined) {
                throw new base_1.RequiredError('letterPk', 'Required parameter letterPk was null or undefined when calling lettersFilesDelete.');
            }
            const localVarPath = `/letters/{letter_pk}/files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"letter_pk"}}`, encodeURIComponent(String(letterPk)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} letterPk
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersFilesList: (letterPk, limit, offset, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'letterPk' is not null or undefined
            if (letterPk === null || letterPk === undefined) {
                throw new base_1.RequiredError('letterPk', 'Required parameter letterPk was null or undefined when calling lettersFilesList.');
            }
            const localVarPath = `/letters/{letter_pk}/files/`
                .replace(`{${"letter_pk"}}`, encodeURIComponent(String(letterPk)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {string} letterPk
         * @param {ModelFile} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersFilesPartialUpdate: (id, letterPk, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling lettersFilesPartialUpdate.');
            }
            // verify required parameter 'letterPk' is not null or undefined
            if (letterPk === null || letterPk === undefined) {
                throw new base_1.RequiredError('letterPk', 'Required parameter letterPk was null or undefined when calling lettersFilesPartialUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling lettersFilesPartialUpdate.');
            }
            const localVarPath = `/letters/{letter_pk}/files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"letter_pk"}}`, encodeURIComponent(String(letterPk)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {string} letterPk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersFilesRead: (id, letterPk, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling lettersFilesRead.');
            }
            // verify required parameter 'letterPk' is not null or undefined
            if (letterPk === null || letterPk === undefined) {
                throw new base_1.RequiredError('letterPk', 'Required parameter letterPk was null or undefined when calling lettersFilesRead.');
            }
            const localVarPath = `/letters/{letter_pk}/files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"letter_pk"}}`, encodeURIComponent(String(letterPk)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {string} id
         * @param {string} letterPk
         * @param {ModelFile} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersFilesUpdate: (id, letterPk, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling lettersFilesUpdate.');
            }
            // verify required parameter 'letterPk' is not null or undefined
            if (letterPk === null || letterPk === undefined) {
                throw new base_1.RequiredError('letterPk', 'Required parameter letterPk was null or undefined when calling lettersFilesUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling lettersFilesUpdate.');
            }
            const localVarPath = `/letters/{letter_pk}/files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"letter_pk"}}`, encodeURIComponent(String(letterPk)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersList: (limit, offset, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/letters/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this letter.
         * @param {Letter} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersPartialUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling lettersPartialUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling lettersPartialUpdate.');
            }
            const localVarPath = `/letters/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this letter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersRead: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling lettersRead.');
            }
            const localVarPath = `/letters/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this letter.
         * @param {Letter} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling lettersUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling lettersUpdate.');
            }
            const localVarPath = `/letters/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * LettersApi - functional programming interface
 * @export
 */
exports.LettersApiFp = function (configuration) {
    return {
        /**
         *
         * @param {Letter} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersCreate(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.LettersApiAxiosParamCreator(configuration).lettersCreate(data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this letter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersDelete(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.LettersApiAxiosParamCreator(configuration).lettersDelete(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Generates pre-signed form data for uploading files to object storage.
         * @param {SignRequest} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersFileSignCreate(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.LettersApiAxiosParamCreator(configuration).lettersFileSignCreate(data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {string} letterPk
         * @param {ModelFile} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersFilesCreate(letterPk, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.LettersApiAxiosParamCreator(configuration).lettersFilesCreate(letterPk, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {string} id
         * @param {string} letterPk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersFilesDelete(id, letterPk, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.LettersApiAxiosParamCreator(configuration).lettersFilesDelete(id, letterPk, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {string} letterPk
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersFilesList(letterPk, limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.LettersApiAxiosParamCreator(configuration).lettersFilesList(letterPk, limit, offset, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {string} id
         * @param {string} letterPk
         * @param {ModelFile} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersFilesPartialUpdate(id, letterPk, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.LettersApiAxiosParamCreator(configuration).lettersFilesPartialUpdate(id, letterPk, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {string} id
         * @param {string} letterPk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersFilesRead(id, letterPk, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.LettersApiAxiosParamCreator(configuration).lettersFilesRead(id, letterPk, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {string} id
         * @param {string} letterPk
         * @param {ModelFile} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersFilesUpdate(id, letterPk, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.LettersApiAxiosParamCreator(configuration).lettersFilesUpdate(id, letterPk, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersList(limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.LettersApiAxiosParamCreator(configuration).lettersList(limit, offset, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this letter.
         * @param {Letter} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersPartialUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.LettersApiAxiosParamCreator(configuration).lettersPartialUpdate(id, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this letter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersRead(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.LettersApiAxiosParamCreator(configuration).lettersRead(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this letter.
         * @param {Letter} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.LettersApiAxiosParamCreator(configuration).lettersUpdate(id, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * LettersApi - factory interface
 * @export
 */
exports.LettersApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @param {Letter} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersCreate(data, options) {
            return exports.LettersApiFp(configuration).lettersCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this letter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersDelete(id, options) {
            return exports.LettersApiFp(configuration).lettersDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates pre-signed form data for uploading files to object storage.
         * @param {SignRequest} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersFileSignCreate(data, options) {
            return exports.LettersApiFp(configuration).lettersFileSignCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} letterPk
         * @param {ModelFile} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersFilesCreate(letterPk, data, options) {
            return exports.LettersApiFp(configuration).lettersFilesCreate(letterPk, data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {string} letterPk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersFilesDelete(id, letterPk, options) {
            return exports.LettersApiFp(configuration).lettersFilesDelete(id, letterPk, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} letterPk
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersFilesList(letterPk, limit, offset, options) {
            return exports.LettersApiFp(configuration).lettersFilesList(letterPk, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {string} letterPk
         * @param {ModelFile} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersFilesPartialUpdate(id, letterPk, data, options) {
            return exports.LettersApiFp(configuration).lettersFilesPartialUpdate(id, letterPk, data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {string} letterPk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersFilesRead(id, letterPk, options) {
            return exports.LettersApiFp(configuration).lettersFilesRead(id, letterPk, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} id
         * @param {string} letterPk
         * @param {ModelFile} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersFilesUpdate(id, letterPk, data, options) {
            return exports.LettersApiFp(configuration).lettersFilesUpdate(id, letterPk, data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersList(limit, offset, options) {
            return exports.LettersApiFp(configuration).lettersList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this letter.
         * @param {Letter} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersPartialUpdate(id, data, options) {
            return exports.LettersApiFp(configuration).lettersPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this letter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersRead(id, options) {
            return exports.LettersApiFp(configuration).lettersRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this letter.
         * @param {Letter} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lettersUpdate(id, data, options) {
            return exports.LettersApiFp(configuration).lettersUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * LettersApi - object-oriented interface
 * @export
 * @class LettersApi
 * @extends {BaseAPI}
 */
class LettersApi extends base_1.BaseAPI {
    /**
     *
     * @param {Letter} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LettersApi
     */
    lettersCreate(data, options) {
        return exports.LettersApiFp(this.configuration).lettersCreate(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this letter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LettersApi
     */
    lettersDelete(id, options) {
        return exports.LettersApiFp(this.configuration).lettersDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Generates pre-signed form data for uploading files to object storage.
     * @param {SignRequest} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LettersApi
     */
    lettersFileSignCreate(data, options) {
        return exports.LettersApiFp(this.configuration).lettersFileSignCreate(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} letterPk
     * @param {ModelFile} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LettersApi
     */
    lettersFilesCreate(letterPk, data, options) {
        return exports.LettersApiFp(this.configuration).lettersFilesCreate(letterPk, data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {string} letterPk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LettersApi
     */
    lettersFilesDelete(id, letterPk, options) {
        return exports.LettersApiFp(this.configuration).lettersFilesDelete(id, letterPk, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} letterPk
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LettersApi
     */
    lettersFilesList(letterPk, limit, offset, options) {
        return exports.LettersApiFp(this.configuration).lettersFilesList(letterPk, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {string} letterPk
     * @param {ModelFile} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LettersApi
     */
    lettersFilesPartialUpdate(id, letterPk, data, options) {
        return exports.LettersApiFp(this.configuration).lettersFilesPartialUpdate(id, letterPk, data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {string} letterPk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LettersApi
     */
    lettersFilesRead(id, letterPk, options) {
        return exports.LettersApiFp(this.configuration).lettersFilesRead(id, letterPk, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} id
     * @param {string} letterPk
     * @param {ModelFile} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LettersApi
     */
    lettersFilesUpdate(id, letterPk, data, options) {
        return exports.LettersApiFp(this.configuration).lettersFilesUpdate(id, letterPk, data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LettersApi
     */
    lettersList(limit, offset, options) {
        return exports.LettersApiFp(this.configuration).lettersList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this letter.
     * @param {Letter} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LettersApi
     */
    lettersPartialUpdate(id, data, options) {
        return exports.LettersApiFp(this.configuration).lettersPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this letter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LettersApi
     */
    lettersRead(id, options) {
        return exports.LettersApiFp(this.configuration).lettersRead(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this letter.
     * @param {Letter} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LettersApi
     */
    lettersUpdate(id, data, options) {
        return exports.LettersApiFp(this.configuration).lettersUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.LettersApi = LettersApi;
/**
 * NotesApi - axios parameter creator
 * @export
 */
exports.NotesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {Note} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesCreate: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling notesCreate.');
            }
            const localVarPath = `/notes/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this note.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesDelete: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling notesDelete.');
            }
            const localVarPath = `/notes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesList: (limit, offset, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/notes/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this note.
         * @param {Note} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesPartialUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling notesPartialUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling notesPartialUpdate.');
            }
            const localVarPath = `/notes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this note.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesRead: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling notesRead.');
            }
            const localVarPath = `/notes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this note.
         * @param {Note} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling notesUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling notesUpdate.');
            }
            const localVarPath = `/notes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * NotesApi - functional programming interface
 * @export
 */
exports.NotesApiFp = function (configuration) {
    return {
        /**
         *
         * @param {Note} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesCreate(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.NotesApiAxiosParamCreator(configuration).notesCreate(data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this note.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesDelete(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.NotesApiAxiosParamCreator(configuration).notesDelete(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesList(limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.NotesApiAxiosParamCreator(configuration).notesList(limit, offset, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this note.
         * @param {Note} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesPartialUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.NotesApiAxiosParamCreator(configuration).notesPartialUpdate(id, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this note.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesRead(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.NotesApiAxiosParamCreator(configuration).notesRead(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this note.
         * @param {Note} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.NotesApiAxiosParamCreator(configuration).notesUpdate(id, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * NotesApi - factory interface
 * @export
 */
exports.NotesApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @param {Note} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesCreate(data, options) {
            return exports.NotesApiFp(configuration).notesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this note.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesDelete(id, options) {
            return exports.NotesApiFp(configuration).notesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesList(limit, offset, options) {
            return exports.NotesApiFp(configuration).notesList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this note.
         * @param {Note} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesPartialUpdate(id, data, options) {
            return exports.NotesApiFp(configuration).notesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this note.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesRead(id, options) {
            return exports.NotesApiFp(configuration).notesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this note.
         * @param {Note} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesUpdate(id, data, options) {
            return exports.NotesApiFp(configuration).notesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * NotesApi - object-oriented interface
 * @export
 * @class NotesApi
 * @extends {BaseAPI}
 */
class NotesApi extends base_1.BaseAPI {
    /**
     *
     * @param {Note} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    notesCreate(data, options) {
        return exports.NotesApiFp(this.configuration).notesCreate(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this note.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    notesDelete(id, options) {
        return exports.NotesApiFp(this.configuration).notesDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    notesList(limit, offset, options) {
        return exports.NotesApiFp(this.configuration).notesList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this note.
     * @param {Note} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    notesPartialUpdate(id, data, options) {
        return exports.NotesApiFp(this.configuration).notesPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this note.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    notesRead(id, options) {
        return exports.NotesApiFp(this.configuration).notesRead(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this note.
     * @param {Note} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    notesUpdate(id, data, options) {
        return exports.NotesApiFp(this.configuration).notesUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.NotesApi = NotesApi;
/**
 * TagsApi - axios parameter creator
 * @export
 */
exports.TagsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {Tag} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsCreate: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling tagsCreate.');
            }
            const localVarPath = `/tags/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this tag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsDelete: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling tagsDelete.');
            }
            const localVarPath = `/tags/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsList: (limit, offset, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/tags/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this tag.
         * @param {Tag} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPartialUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling tagsPartialUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling tagsPartialUpdate.');
            }
            const localVarPath = `/tags/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this tag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsRead: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling tagsRead.');
            }
            const localVarPath = `/tags/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {number} id A unique integer value identifying this tag.
         * @param {Tag} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling tagsUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling tagsUpdate.');
            }
            const localVarPath = `/tags/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * TagsApi - functional programming interface
 * @export
 */
exports.TagsApiFp = function (configuration) {
    return {
        /**
         *
         * @param {Tag} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsCreate(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TagsApiAxiosParamCreator(configuration).tagsCreate(data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this tag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsDelete(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TagsApiAxiosParamCreator(configuration).tagsDelete(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsList(limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TagsApiAxiosParamCreator(configuration).tagsList(limit, offset, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this tag.
         * @param {Tag} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPartialUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TagsApiAxiosParamCreator(configuration).tagsPartialUpdate(id, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this tag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsRead(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TagsApiAxiosParamCreator(configuration).tagsRead(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @param {number} id A unique integer value identifying this tag.
         * @param {Tag} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TagsApiAxiosParamCreator(configuration).tagsUpdate(id, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * TagsApi - factory interface
 * @export
 */
exports.TagsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @param {Tag} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsCreate(data, options) {
            return exports.TagsApiFp(configuration).tagsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this tag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsDelete(id, options) {
            return exports.TagsApiFp(configuration).tagsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsList(limit, offset, options) {
            return exports.TagsApiFp(configuration).tagsList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this tag.
         * @param {Tag} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsPartialUpdate(id, data, options) {
            return exports.TagsApiFp(configuration).tagsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this tag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsRead(id, options) {
            return exports.TagsApiFp(configuration).tagsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} id A unique integer value identifying this tag.
         * @param {Tag} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsUpdate(id, data, options) {
            return exports.TagsApiFp(configuration).tagsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
class TagsApi extends base_1.BaseAPI {
    /**
     *
     * @param {Tag} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    tagsCreate(data, options) {
        return exports.TagsApiFp(this.configuration).tagsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this tag.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    tagsDelete(id, options) {
        return exports.TagsApiFp(this.configuration).tagsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    tagsList(limit, offset, options) {
        return exports.TagsApiFp(this.configuration).tagsList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this tag.
     * @param {Tag} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    tagsPartialUpdate(id, data, options) {
        return exports.TagsApiFp(this.configuration).tagsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this tag.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    tagsRead(id, options) {
        return exports.TagsApiFp(this.configuration).tagsRead(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {number} id A unique integer value identifying this tag.
     * @param {Tag} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    tagsUpdate(id, data, options) {
        return exports.TagsApiFp(this.configuration).tagsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TagsApi = TagsApi;
/**
 * UsersApi - axios parameter creator
 * @export
 */
exports.UsersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * API endpoint that allows users to be viewed or edited.
         * @param {User} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreate: (data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling usersCreate.');
            }
            const localVarPath = `/users/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API endpoint that allows users to be viewed or edited.
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDelete: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling usersDelete.');
            }
            const localVarPath = `/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API endpoint that allows users to be viewed or edited.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList: (limit, offset, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/users/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API endpoint that allows users to be viewed or edited.
         * @param {number} id A unique integer value identifying this user.
         * @param {User} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling usersPartialUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling usersPartialUpdate.');
            }
            const localVarPath = `/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API endpoint that allows users to be viewed or edited.
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRead: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling usersRead.');
            }
            const localVarPath = `/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API endpoint that allows users to be viewed or edited.
         * @param {number} id A unique integer value identifying this user.
         * @param {User} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate: (id, data, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling usersUpdate.');
            }
            // verify required parameter 'data' is not null or undefined
            if (data === null || data === undefined) {
                throw new base_1.RequiredError('data', 'Required parameter data was null or undefined when calling usersUpdate.');
            }
            const localVarPath = `/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof data !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(data !== undefined ? data : {}) : (data || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * UsersApi - functional programming interface
 * @export
 */
exports.UsersApiFp = function (configuration) {
    return {
        /**
         * API endpoint that allows users to be viewed or edited.
         * @param {User} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreate(data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UsersApiAxiosParamCreator(configuration).usersCreate(data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * API endpoint that allows users to be viewed or edited.
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDelete(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UsersApiAxiosParamCreator(configuration).usersDelete(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * API endpoint that allows users to be viewed or edited.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList(limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UsersApiAxiosParamCreator(configuration).usersList(limit, offset, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * API endpoint that allows users to be viewed or edited.
         * @param {number} id A unique integer value identifying this user.
         * @param {User} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UsersApiAxiosParamCreator(configuration).usersPartialUpdate(id, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * API endpoint that allows users to be viewed or edited.
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRead(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UsersApiAxiosParamCreator(configuration).usersRead(id, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * API endpoint that allows users to be viewed or edited.
         * @param {number} id A unique integer value identifying this user.
         * @param {User} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate(id, data, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UsersApiAxiosParamCreator(configuration).usersUpdate(id, data, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * UsersApi - factory interface
 * @export
 */
exports.UsersApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * API endpoint that allows users to be viewed or edited.
         * @param {User} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreate(data, options) {
            return exports.UsersApiFp(configuration).usersCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows users to be viewed or edited.
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDelete(id, options) {
            return exports.UsersApiFp(configuration).usersDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows users to be viewed or edited.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList(limit, offset, options) {
            return exports.UsersApiFp(configuration).usersList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows users to be viewed or edited.
         * @param {number} id A unique integer value identifying this user.
         * @param {User} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate(id, data, options) {
            return exports.UsersApiFp(configuration).usersPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows users to be viewed or edited.
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRead(id, options) {
            return exports.UsersApiFp(configuration).usersRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API endpoint that allows users to be viewed or edited.
         * @param {number} id A unique integer value identifying this user.
         * @param {User} data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate(id, data, options) {
            return exports.UsersApiFp(configuration).usersUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
class UsersApi extends base_1.BaseAPI {
    /**
     * API endpoint that allows users to be viewed or edited.
     * @param {User} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    usersCreate(data, options) {
        return exports.UsersApiFp(this.configuration).usersCreate(data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API endpoint that allows users to be viewed or edited.
     * @param {number} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    usersDelete(id, options) {
        return exports.UsersApiFp(this.configuration).usersDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API endpoint that allows users to be viewed or edited.
     * @param {number} [limit] Number of results to return per page.
     * @param {number} [offset] The initial index from which to return the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    usersList(limit, offset, options) {
        return exports.UsersApiFp(this.configuration).usersList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API endpoint that allows users to be viewed or edited.
     * @param {number} id A unique integer value identifying this user.
     * @param {User} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    usersPartialUpdate(id, data, options) {
        return exports.UsersApiFp(this.configuration).usersPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API endpoint that allows users to be viewed or edited.
     * @param {number} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    usersRead(id, options) {
        return exports.UsersApiFp(this.configuration).usersRead(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API endpoint that allows users to be viewed or edited.
     * @param {number} id A unique integer value identifying this user.
     * @param {User} data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    usersUpdate(id, data, options) {
        return exports.UsersApiFp(this.configuration).usersUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UsersApi = UsersApi;
